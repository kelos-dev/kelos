name: Label

on:
  issues:
    types: [opened, labeled, unlabeled]
  pull_request_target:
    types: [opened, labeled, unlabeled]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

permissions:
  issues: write
  pull-requests: write

jobs:
  sync-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Sync needs-* labels
        uses: actions/github-script@v7
        with:
          script: |
            const item = context.payload.issue || context.payload.pull_request;
            const labels = item.labels.map(l => l.name);

            const rules = [
              { prefix: null, match: 'triage-accepted', needs: 'needs-triage' },
              { prefix: 'kind/', match: null, needs: 'needs-kind' },
              { prefix: 'priority/', match: null, needs: 'needs-priority' },
              { prefix: 'actor/', match: null, needs: 'needs-actor' },
            ];

            const errors = [];
            for (const rule of rules) {
              try {
                const satisfied = rule.match
                  ? labels.includes(rule.match)
                  : labels.some(l => l.startsWith(rule.prefix));
                const hasNeeds = labels.includes(rule.needs);

                if (!satisfied && !hasNeeds) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: item.number,
                    labels: [rule.needs],
                  });
                } else if (satisfied && hasNeeds) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: item.number,
                      name: rule.needs,
                    });
                  } catch (e) {
                    if (e.status !== 404) throw e;
                  }
                }
              } catch (e) {
                errors.push({ rule: rule.needs, error: e });
                core.warning(`Failed to sync ${rule.needs}: ${e.message}`);
              }
            }
            if (errors.length > 0) {
              throw new Error(`Failed to sync labels: ${errors.map(e => e.rule).join(', ')}`);
            }
